{
  "name": "selector",
  "files": [
    {
      "name": "selector.tsx",
      "content": "import {\n  Dispatch,\n  ReactNode,\n  SetStateAction,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\"\nimport { Check, Filter } from \"lucide-react\"\nimport { twMerge } from \"tailwind-merge\"\n\nimport { cn } from \"@/lib/utils\"\nimport { Button, ButtonProps } from \"@/registry/new-york/ui/button\"\nimport { Checkbox } from \"@/registry/new-york/ui/checkbox\"\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n} from \"@/registry/new-york/ui/command\"\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from \"@/registry/new-york/ui/popover\"\n\ntype Accessor<T> = (data: T) => string | number\n\ntype TriggerProps = Omit<ButtonProps, \"onClick\">\n\ntype UnselectReselectMode<T> = {\n  onSelectedClick?: \"unselect\"\n  onSelectChange: (props: {\n    added?: T | undefined\n    removed?: T | undefined\n  }) => void\n}\n\ntype DefaultReselectMode<T> = {\n  onSelectedClick: \"reselect\" | \"ignore\"\n  onSelectChange: (props: { added: T; removed?: never }) => void\n}\n\ntype SingleProps<T, R extends (...args: any[]) => any = Accessor<T>> = {\n  mode?: \"single\"\n  valueAccessor: R\n  selected?: ReturnType<R> | null\n  renderLabel?: (value: T) => NonNullable<ReactNode>\n}\n\ntype MultipleProps<T, R extends (...args: any[]) => any = Accessor<T>> = {\n  mode: \"multiple\"\n  valueAccessor: R\n  selected?: ReturnType<R>[]\n  renderLabel?: (value: T[]) => NonNullable<ReactNode>\n}\n\ntype SelectorSearch<T, DataT> = {\n  accessor?: (data: T) => Array<string | null>\n  filter?: (value: string, search: string) => number\n  renderSearch?: (InputComponent: typeof CommandInput, data: DataT) => ReactNode\n  query?: string\n  onSearchChange?: (search: string) => void\n  suppressFiltering?: boolean\n}\n\ntype CoreProps<T, DataT = T[] | Record<string, T[]>> = {\n  data: DataT\n  renderValue?: (\n    value: T,\n    disabled?: boolean | undefined\n  ) => NonNullable<ReactNode>\n  renderSelectedIcon?: (value: T) => ReactNode\n  customId?: (data: T) => string | number\n  filters?: Array<{\n    label: string\n    filter: (data: T) => boolean\n    defaultEnabled?: boolean\n  }>\n  triggerProps?: TriggerProps\n  contentStyles?: string\n  placeholder?: ReactNode\n  search?: SelectorSearch<T, DataT>\n  disabledAccessor?: (value: T) => boolean\n}\n\nfunction Selector<T>({\n  mode = \"single\",\n  data,\n  selected: selectedExt,\n  onSelectedClick = \"unselect\",\n  onSelectChange,\n  search,\n  valueAccessor,\n  renderLabel,\n  renderValue,\n  renderSelectedIcon,\n  triggerProps,\n  contentStyles,\n  placeholder,\n  disabledAccessor,\n  customId = valueAccessor,\n  filters = [],\n}: CoreProps<T> &\n  (SingleProps<T> | MultipleProps<T>) &\n  (UnselectReselectMode<T> | DefaultReselectMode<T>)) {\n  const [selected, setSelected] = useState(\n    mode === \"single\"\n      ? typeof selectedExt === \"string\"\n        ? selectedExt || null\n        : selectedExt ?? null\n      : selectedExt ?? []\n  )\n  const [open, setOpen] = useState(false)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const separator = \"~\"\n\n  const searchAccessor = search?.accessor\n  const createChoiceNameId = useCallback(\n    (choice: T) => {\n      const res =\n        searchAccessor?.(choice).reduce(\n          (acc, curr) => (acc += curr ? `${curr} ` : \"\"),\n          \"\"\n        ) ?? \"\"\n\n      return `${res}${separator}${valueAccessor(choice)}` as const\n    },\n    [searchAccessor, valueAccessor]\n  )\n  type CustomId = ReturnType<typeof createChoiceNameId>\n  const getCustomChoiceId = useCallback(\n    (id: CustomId) => id.split(separator)[1]!,\n    []\n  )\n\n  const flattenedChoices = useMemo(\n    () => (Array.isArray(data) ? data : Object.values(data).flat()),\n    [data]\n  )\n\n  const label = useMemo(() => {\n    if (mode === \"multiple\" && Array.isArray(selected)) {\n      const options = flattenedChoices.filter((v) =>\n        selected.includes(valueAccessor(v))\n      )\n\n      return options.length > 0\n        ? (renderLabel as MultipleProps<T>[\"renderLabel\"])?.(options) ??\n            options.map(valueAccessor).join(\", \")\n        : placeholder ?? \"-\"\n    } else if (mode === \"single\" && !Array.isArray(selected)) {\n      const option = flattenedChoices.find((v) => valueAccessor(v) == selected)\n\n      return selected !== null && typeof option !== \"undefined\"\n        ? (renderLabel as SingleProps<T>[\"renderLabel\"])?.(option) ??\n            renderValue?.(option, disabledAccessor?.(option)) ??\n            valueAccessor(option)\n        : placeholder ?? triggerProps?.value ?? triggerProps?.children ?? \"-\"\n    } else return `!invalid label state!`\n  }, [\n    selected,\n    flattenedChoices,\n    mode,\n    valueAccessor,\n    renderValue,\n    disabledAccessor,\n    renderLabel,\n    placeholder,\n    triggerProps?.value,\n    triggerProps?.children,\n  ])\n\n  const [filtersState, setFilters] = useState(\n    filters.map((v) => ({ ...v, enabled: v.defaultEnabled ?? false }))\n  )\n\n  //resolve nullish `selected` values\n  useEffect(() => {\n    setSelected(\n      mode === \"single\"\n        ? typeof selectedExt === \"string\"\n          ? selectedExt || null\n          : selectedExt ?? null\n        : selectedExt ?? []\n    )\n  }, [mode, selectedExt])\n\n  const handleSelect = useCallback(\n    (mixedValue: string, choices: T[]) => {\n      const value = getCustomChoiceId(mixedValue as CustomId)\n      const choice = choices.find(\n        //? normalized comparison, radix lowers caps\n        (v) => valueAccessor(v).toString().toLowerCase() == value\n      )\n      if (typeof choice === \"undefined\") return\n      if (mode === \"single\" && !Array.isArray(selected)) {\n        //is already selected\n        if (selected !== null && valueAccessor(choice) == selected) {\n          switch (onSelectedClick) {\n            case \"unselect\": {\n              setSelected(null)\n              const onSelect =\n                onSelectChange as UnselectReselectMode<T>[\"onSelectChange\"]\n              onSelect({\n                removed: choice,\n              })\n              break\n            }\n\n            case \"reselect\": {\n              onSelectChange({ added: choice })\n              break\n            }\n\n            case \"ignore\":\n            default: {\n              break\n            }\n          }\n        } else {\n          //* re-access to avoid normalization\n          setSelected(valueAccessor(choice))\n          onSelectChange({ added: choice })\n        }\n\n        return setOpen(false)\n      } else if (mode === \"multiple\" && Array.isArray(selected)) {\n        const existingIndex = selected.findIndex(\n          (v) => v == valueAccessor(choice)\n        )\n\n        if (existingIndex === -1) {\n          const newSelected = [...(selected as []), valueAccessor(choice)]\n\n          setSelected(newSelected)\n          onSelectChange({ added: choice })\n        } else {\n          switch (onSelectedClick) {\n            case \"unselect\": {\n              const newSelected = (selected as (string | number)[]).filter(\n                (v, i) => i !== existingIndex\n              )\n              setSelected(newSelected)\n              const onSelect =\n                onSelectChange as UnselectReselectMode<T>[\"onSelectChange\"]\n              onSelect({\n                removed: choice,\n              })\n              break\n            }\n\n            case \"reselect\": {\n              const newSelected = [...(selected as []), valueAccessor(choice)]\n\n              setSelected(newSelected)\n              onSelectChange({ added: choice })\n              break\n            }\n\n            case \"ignore\":\n            default: {\n              break\n            }\n          }\n        }\n      }\n    },\n\n    [\n      mode,\n      selected,\n      onSelectedClick,\n      valueAccessor,\n      onSelectChange,\n      getCustomChoiceId,\n    ]\n  )\n\n  const renderOptions = useMemo(\n    () => (data: T[]) => {\n      return data\n        .filter((v) => {\n          const enabledFilters = filtersState.filter((v) => v.enabled)\n\n          return enabledFilters.length > 0\n            ? enabledFilters.every((f) => f.filter(v))\n            : true\n        })\n        .map((choice) => (\n          <CommandItem\n            disabled={disabledAccessor?.(choice)}\n            key={customId(choice)}\n            value={createChoiceNameId(choice)}\n            onSelect={(v) => handleSelect(v, data)}\n          >\n            {renderSelectedIcon?.(choice) ?? (\n              <Check\n                className={cn(\n                  \"mr-2 h-4 w-4\",\n                  selected !== null\n                    ? mode === \"single\" &&\n                      !Array.isArray(selected) &&\n                      selected == valueAccessor(choice)\n                      ? \"opacity-100\"\n                      : Array.isArray(selected) &&\n                        selected.find((v) => v == valueAccessor(choice))\n                      ? \"opacity-100\"\n                      : \"opacity-0\"\n                    : \"opacity-0\"\n                )}\n              />\n            )}\n            <span\n              className={disabledAccessor?.(choice) ? \"cursor-not-allowed\" : \"\"}\n            >\n              {renderValue?.(choice, disabledAccessor?.(choice)) ?? (\n                <span\n                  className={disabledAccessor?.(choice) ? \"opacity-50\" : \"\"}\n                >\n                  {valueAccessor(choice) ?? \"-\"}\n                </span>\n              )}\n            </span>\n          </CommandItem>\n        ))\n    },\n    [\n      mode,\n      selected,\n      filtersState,\n      customId,\n      renderValue,\n      handleSelect,\n      valueAccessor,\n      disabledAccessor,\n      createChoiceNameId,\n      renderSelectedIcon,\n    ]\n  )\n\n  return (\n    <div id=\"selector-container\" ref={containerRef}>\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          <Button\n            {...triggerProps}\n            className={twMerge(\"w-fit\", triggerProps?.className)}\n            type=\"button\"\n            variant=\"outline\"\n          >\n            {label}\n          </Button>\n        </PopoverTrigger>\n        <PopoverContent\n          className={twMerge(\"min-w-max max-w-0\", contentStyles)}\n          style={{ width: containerRef.current?.offsetWidth }}\n          hideWhenDetached\n        >\n          <Command\n            shouldFilter={!search?.suppressFiltering}\n            filter={search?.filter}\n          >\n            {search\n              ? search.renderSearch?.(CommandInput, data) ?? (\n                  <div>\n                    <CommandInput\n                      value={search.query}\n                      onValueChange={(v) => search.onSearchChange?.(v)}\n                    />\n                  </div>\n                )\n              : null}\n            <FiltersButton filters={filtersState} setFilters={setFilters} />\n            <CommandList>\n              <CommandEmpty>No results found.</CommandEmpty>\n              {Array.isArray(data) ? (\n                <CommandGroup>{renderOptions(data)}</CommandGroup>\n              ) : (\n                Object.entries(data).map(([group, choices]) =>\n                  choices.length > 0 ? (\n                    <CommandGroup heading={group} key={group}>\n                      {renderOptions(choices)}\n                    </CommandGroup>\n                  ) : null\n                )\n              )}\n            </CommandList>\n          </Command>\n        </PopoverContent>\n      </Popover>\n    </div>\n  )\n}\n\ntype FiltersButtonProps<T> = {\n  filters: Array<T>\n  setFilters: Dispatch<SetStateAction<Array<T>>>\n}\n\nfunction FiltersButton<T extends { label: string; enabled: boolean }>({\n  filters,\n  setFilters,\n}: FiltersButtonProps<T>) {\n  const enabled = useMemo(() => filters.filter((v) => v.enabled), [filters])\n\n  return filters.length === 0 ? null : (\n    <Popover>\n      <div className=\"m-1 flex justify-end\">\n        <PopoverTrigger asChild>\n          <Button\n            size=\"icon\"\n            variant={\"outline\"}\n            className={`${\n              enabled.length > 0\n                ? \"hover:bg-primary-500 bg-primary text-primary-foreground hover:text-primary-foreground\"\n                : \"\"\n            } scale-75 font-bold`}\n          >\n            <Filter\n              className={\n                enabled.length > 0\n                  ? \"text-primary-foreground\"\n                  : \"text-secondary-foreground\"\n              }\n            />\n          </Button>\n        </PopoverTrigger>\n      </div>\n\n      <PopoverContent side=\"right\" className=\"max-w-fit overflow-y-auto\">\n        <div className=\"m-2 flex flex-col gap-2 text-sm\">\n          {filters.map(({ enabled, label }, i) => (\n            <div key={i} className=\"flex items-center space-x-2\">\n              <Checkbox\n                checked={enabled}\n                onCheckedChange={(checked) => {\n                  setFilters((prev) =>\n                    prev.map((v) => {\n                      const found = v.label === label\n\n                      return {\n                        ...v,\n                        enabled: found ? !!checked : v.enabled,\n                      }\n                    })\n                  )\n                }}\n              />\n              <label\n                htmlFor=\"terms\"\n                className=\"text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70\"\n              >\n                {label}\n              </label>\n            </div>\n          ))}\n        </div>\n      </PopoverContent>\n    </Popover>\n  )\n}\n\nexport { Selector }\n"
    }
  ],
  "type": "components:ui"
}